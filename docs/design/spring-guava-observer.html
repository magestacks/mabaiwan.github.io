<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Spring、Guava 框架如何设计观察者模式？ | 小马哥の代码实战课</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/assets/xiaomage-logo.JPG">
    <script type="text/javascript" src="/assets/js/push.js"></script>
    <script charset="utf-8" src="https://my.openwrite.cn/js/readmore.js"></script>
    <meta name="description" content="一个不是在造轮子，就是在造轮子路上的程序员，追求优雅编码。写过博客，参与过开源项目，热衷于基础架构。">
    <meta name="referrer" content="never">
    <meta name="keywords" content="antdocs,antdeisgn,vuepress,vuepress-theme,theme,ant,docs,antd,antdocs of vuepress,主题,vuepress主题,antd设计,blog,vuepress-blog">
    <link rel="preload" href="/assets/css/0.styles.b37e4d9f.css" as="style"><link rel="preload" href="/assets/js/app.7eb18571.js" as="script"><link rel="preload" href="/assets/js/2.670b9761.js" as="script"><link rel="preload" href="/assets/js/18.eb50631d.js" as="script"><link rel="prefetch" href="/assets/js/10.a5a9903d.js"><link rel="prefetch" href="/assets/js/11.5762fdcb.js"><link rel="prefetch" href="/assets/js/12.3d30dbb9.js"><link rel="prefetch" href="/assets/js/13.167f50d8.js"><link rel="prefetch" href="/assets/js/14.73090bec.js"><link rel="prefetch" href="/assets/js/15.c99b25a1.js"><link rel="prefetch" href="/assets/js/16.8e1e672b.js"><link rel="prefetch" href="/assets/js/17.3f44f769.js"><link rel="prefetch" href="/assets/js/19.b81fb5c1.js"><link rel="prefetch" href="/assets/js/20.9e106839.js"><link rel="prefetch" href="/assets/js/21.899094ac.js"><link rel="prefetch" href="/assets/js/22.20904317.js"><link rel="prefetch" href="/assets/js/23.54f25aab.js"><link rel="prefetch" href="/assets/js/24.9980ebcd.js"><link rel="prefetch" href="/assets/js/25.3068a180.js"><link rel="prefetch" href="/assets/js/26.b9dbabce.js"><link rel="prefetch" href="/assets/js/27.fe33b48c.js"><link rel="prefetch" href="/assets/js/28.53c3669d.js"><link rel="prefetch" href="/assets/js/29.aea97b6c.js"><link rel="prefetch" href="/assets/js/3.f8b3c6d2.js"><link rel="prefetch" href="/assets/js/30.601a6826.js"><link rel="prefetch" href="/assets/js/31.c8fd8006.js"><link rel="prefetch" href="/assets/js/32.679c3c46.js"><link rel="prefetch" href="/assets/js/33.0632bf2f.js"><link rel="prefetch" href="/assets/js/34.87ee7489.js"><link rel="prefetch" href="/assets/js/35.ae124e8e.js"><link rel="prefetch" href="/assets/js/36.0b5e4932.js"><link rel="prefetch" href="/assets/js/37.241fb3e7.js"><link rel="prefetch" href="/assets/js/38.20592ee2.js"><link rel="prefetch" href="/assets/js/39.bec8855a.js"><link rel="prefetch" href="/assets/js/4.fa07bc29.js"><link rel="prefetch" href="/assets/js/40.19c4f912.js"><link rel="prefetch" href="/assets/js/41.efec0c07.js"><link rel="prefetch" href="/assets/js/5.ac01bbe0.js"><link rel="prefetch" href="/assets/js/6.e506f546.js"><link rel="prefetch" href="/assets/js/7.929e0a1e.js"><link rel="prefetch" href="/assets/js/8.5a319efc.js"><link rel="prefetch" href="/assets/js/9.0dc60c38.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b37e4d9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-6 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active home-link"><img src="/assets/xiaomage-logo.JPG" alt="小马哥の代码实战课" class="logo"> <span class="site-name">小马哥の代码实战课</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-18 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="https://sourl.cn/ruwYW4" target="_blank">
          🥇代码实战课
          <i aria-label="icon: link" class="anticon anticon-link"><svg viewBox="64 64 896 896" focusable="false" data-icon="link" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M574 665.4a8.03 8.03 0 0 0-11.3 0L446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3l-39.8-39.8a8.03 8.03 0 0 0-11.3 0L191.4 526.5c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3L574 665.4zm258.6-474c-84.6-84.6-221.5-84.6-306 0L410.3 307.6a8.03 8.03 0 0 0 0 11.3l39.7 39.7c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204L665.3 562.6a8.03 8.03 0 0 0 0 11.3l39.8 39.8c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c84.5-84.6 84.5-221.5 0-306.1zM610.1 372.3a8.03 8.03 0 0 0-11.3 0L372.3 598.7a8.03 8.03 0 0 0 0 11.3l39.6 39.6c3.1 3.1 8.2 3.1 11.3 0l226.4-226.4c3.1-3.1 3.1-8.2 0-11.3l-39.5-39.6z"></path></svg></i></a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/docs/thread/thread-pool-thread-destroy.html">
          技术笔记
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <ul class="extra-group"><li><a href="https://github.com/mageeric" target="_blank" rel="noopener noreferrer" class="repo-link"><i aria-label="icon: github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></i></a></li> <!----></ul></nav></div></div> <!----></header> <aside class="sidebar"><div><div class="promo"><div id="promo_3"><div class="promo_title">赞助商</div> <button type="button" class="ant-btn ant-btn-primary ant-btn-background-ghost"><span>成为赞助商</span></button></div></div> <div role="separator" id="reset-margin" class="ant-divider ant-divider-horizontal ant-divider-dashed"></div></div>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发编程</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>设计模式</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/design/spring-guava-observer.html" aria-current="page" title="Spring、Guava 框架如何设计观察者模式？" class="active sidebar-link">Spring、Guava 框架如何设计观察者模式？</a></li><li><a href="/docs/design/identity-auth.html" title="图解设计模式：身份认证场景的应用" class="sidebar-link">图解设计模式：身份认证场景的应用</a></li><li><a href="/docs/design/strategy.html" title="摊牌了！策略模式在项目设计中用的最多" class="sidebar-link">摊牌了！策略模式在项目设计中用的最多</a></li><li><a href="/docs/design/chain.html" title="春节期间，我用责任链模式重构了业务代码" class="sidebar-link">春节期间，我用责任链模式重构了业务代码</a></li><li><a href="/docs/design/spi.html" title="某厂面试：如何优雅使用 SPI 机制？" class="sidebar-link">某厂面试：如何优雅使用 SPI 机制？</a></li><li><a href="/docs/design/hutool-builder.html" title="火遍全网的 Hutool，如何使用 Builder 模式创建线程池？" class="sidebar-link">火遍全网的 Hutool，如何使用 Builder 模式创建线程池？</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>场景问题</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式篇</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架学习</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>读书笔记</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="spring、guava-框架如何设计观察者模式">Spring、Guava 框架如何设计观察者模式？ <a href="#spring、guava-框架如何设计观察者模式" class="header-anchor">#</a></h1> <p>今天讲解一篇行为型设计模式，什么是行为型？行为型主要负责设计 <strong>类或对象之间的交互</strong>。工作中常用的观察者模式就是一种行为型设计模式</p> <p>最近在尝试重构之前写过的代码。在重新梳理过业务之后，发现已有的设计场景应该能够接入到设计模式，而且查看了代码的提交记录，更是坚定了此想法</p> <p>保持之前的一贯作风，想要说明一个设计模式，需要三板斧支撑。什么是观察者模式？如何使用观察者模式？项目中应该如何应用？</p> <blockquote><p>观察者设计模式大纲如下：</p> <ol><li>什么是观察者模式</li> <li>观察者模式代码如何写</li> <li>如何使用观察者模式结合业务</li> <li>Guava EventBus 观察者模式</li> <li>Spring ApplicationEvent 事件模型</li> <li>观察者模式最后的总结</li></ol></blockquote> <h2 id="什么是观察者模式">什么是观察者模式 <a href="#什么是观察者模式" class="header-anchor">#</a></h2> <p><strong>观察者模式</strong> 是一种行为设计模式，允许定义一种订阅通知机制，可以在对象（被观察者）事件发生时通知多个 “观察” 该对象的观察者对象，所以也被称为 <strong>发布订阅模式</strong></p> <p>其实我个人而言，<strong>不太喜欢使用文字去定义一种设计模式的语义</strong>，因为这样总是难以理解。所以就有了下面生活中的例子，来帮助读者更好的去理解模式的语义。类图如下所示：</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210328185857885.png" alt=""></p> <p>在举例说明前，先让我们熟悉下观察者模式中的 <code>角色类型</code> 以及代码示例。观察者模式由以下几部分角色组成，可以参考代码示例去理解，不要被文字描述带偏</p> <ul><li><strong>主题（被观察者）</strong>（Subject）：抽象主题角色把所有观察者对象保存在一个容器里，提供添加和移除观察者接口，并且提供出通知所有观察者对象接口（也有作者通过 <code>Observable</code> 描述）</li> <li><strong>具体主题（具体被观察者）</strong>（Concrete Subject）：具体主题角色的职责就是<code>实现抽象目标角色的接口语义</code>，在被观察者状态更改时，给容器内所有注册观察者发送状态通知</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Observer</span> observer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 添加观察者</span>
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Observer</span> observer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移除观察者</span>
    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知所有观察者事件</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Observer</span><span class="token punctuation">&gt;</span></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Observer</span> observer<span class="token punctuation">)</span> <span class="token punctuation">{</span> observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Observer</span> observer<span class="token punctuation">)</span> <span class="token punctuation">{</span> observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span> observers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>each <span class="token operator">-&gt;</span> each<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>抽象观察者</strong>（Observer）：抽象观察者角色是观察者的行为抽象，它定义了一个修改接口，当被观察者发出事件时通知自己</li> <li><strong>具体观察者</strong>（Concrete Observer）：实现抽象观察者定义的更新接口，可以在被观察者发出事件时通知自己</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// String 入参只是举例, 真实业务不会限制</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserverOne</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行 message 逻辑</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接收到被观察者状态变更-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserverTwo</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行 message 逻辑</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接收到被观察者状态变更-2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们跑一下上面的观察者模式示例，如果不出意外的话会将两个观察者执行逻辑中的日志打印输出。如果是平常业务逻辑，抽象观察者定义的入参是具有业务意义的，大家可以类比项目上使用到的 MQ Message 机制</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConcreteSubject</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subject<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteObserverOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subject<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteObserverTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subject<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">&quot;被观察者状态改变, 通知所有已注册观察者&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="观察者模式结合业务">观察者模式结合业务 <a href="#观察者模式结合业务" class="header-anchor">#</a></h2> <p>因为公司业务场景保密，所以下面我们通过【新警察故事】的电影情节，稍微篡改下剧情，模拟出我们的观察者模式应用场景</p> <p>假设：目前我们有三个警察，分别是<code>龙哥、锋哥、老三</code>，他们受命跟进犯罪嫌疑人<strong>阿祖</strong>。如果发现犯罪嫌疑人阿祖有动静，龙哥、峰哥负责实施抓捕行动，老三向警察局摇人，流程图如下：</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210322195538070.png" alt=""></p> <p>如果说使用常规代码写这套流程，是能够实现需求的，一把梭的逻辑可以实现一切需求。但是，如果说下次行动，龙哥让老三跟着自己实施抓捕，亦或者说龙哥团队扩张，来了老四、老五、老六...</p> <blockquote><p>对比观察者模式角色定义，老四、老五、老六都是具体的观察者（Concrete Observer）</p></blockquote> <p>如果按照上面的设想，我们通过“一把梭”的方式把代码写出来会有什么问题呢？如下：</p> <ol><li><p>首当其冲，<strong>增加了代码的复杂性</strong>。实现类或者说这个方法函数奇大无比，因为随着警员的扩张，代码块会越来越大</p></li> <li><p><strong>违背了开闭原则</strong>，因为会频繁改动不同警员的任务。每个警员的任务不是一成不变的，举个例子来说这次针对疑犯，让峰哥实施的抓捕行动，下次就可能是疏散民众，难道每次的更改都需要改动“一把梭”的代码</p></li></ol> <p>第一种我们可以通过，<strong>大函数拆小函数</strong> 或者 <strong>大类拆分为小类</strong> 的方式解决代码负责性问题。但是，开闭原则却不能避免掉，因为随着警员（观察者）的增多及减少，势必会面临频繁改动原函数的情况</p> <p>当我们面对这种 <strong>已知会变动</strong>，并且可能会 <strong>频繁变动不固定</strong> 的代码，就要使用抽象思维来进行设计，进而保持代码的简洁、可维护</p> <p>这里使用 Java SpringBoot 项目结构来书写观察者模式，代码最终推送到 Github 仓库。<strong>读者可以先把仓库拉下来</strong>，因为其中不止示例代码，还包括 Guava 和 Spring 的观察者模式实现，<a href="https://github.com/JavaSouce/design" target="_blank" rel="noopener noreferrer">GitHub 仓库地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>首先，定义观察者模式中的观察者角色，分别为抽象观察者接口以及三个具体观察者实现类。实际业务中，设计模式会和 Spring 框架相结合，所以示例代码中包含 Spring 相关注解及接口</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210328120411550.png" alt=""></p> <p>其次，定义抽象被观察者接口以及具体被观察者实现类。同上，被观察者也需要成为 Spring Bean，托管于 IOC 容器管理</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210328123639110.png" alt=""></p> <p>到这里，一个完整的观察者模式就完成了。但是，细心的读者会发现这样的观察者模式会有一个小问题，这里先不说明，继续往下看。接下来就需要实际操练一番，注册这些观察者，通过被观察者触发事件来通知观察者</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210328125454787.png" alt=""></p> <h3 id="如何实现开闭原则">如何实现开闭原则 <a href="#如何实现开闭原则" class="header-anchor">#</a></h3> <p>看了应用的代码之后，函数体过大的问题已经被解决了，我们通过 <strong>拆分成为不同的具体的观察者类</strong> 来拆分总体逻辑。但是开闭原则问题呢？这就是上面所说的问题所在，我们目前是通过 <strong>显示的引入具体观察者模式</strong> 来进行添加到被观察者的通知容器中，如果后续添加警察老四、老五... 越来越多的警察时，还是需要改动原有代码，问题应该怎么解决呢</p> <p>其实非常简单，平常 Web 项目基本都会使用 Spring 框架开发，那自然是要运用其中的特性解决场景问题。我们这里通过 <strong>改造具体被观察者实现开闭原则</strong></p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210328130024382.png" alt=""></p> <p>如果看过之前作者写过的设计模式文章，对 <code>InitializingBean</code> 接口不会感到陌生，我们在 <code>afterPropertiesSet</code> 方法中，通过注入的 <strong>IOC 容器获取到所有观察者对象</strong> 并添加至被观察者通知容器中。这样的话，触发观察者事件，代码中只需要一行即可完成通知</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@PostConstruct</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 被观察者触发事件, 通知所有观察者</span>
    subject<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">&quot;阿祖有行动！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>后续如果再有新的观察者类添加，只需要创建新的类实现抽象观察者接口即可完成需求。有时候，<strong>能够被封装起来的不止是 DateUtil 类型的工具类</strong>，一些设计模式也可以被封装，<strong>继而更好的服务开发者灵活运用</strong>。这里会分别介绍 <code>Guava#EventBus</code> 以及 <code>Spring#事件模型</code></p> <h3 id="同步异步的概念">同步异步的概念 <a href="#同步异步的概念" class="header-anchor">#</a></h3> <p>在介绍 <code>EventBus</code> 和 <code>Spring</code> 事件模型之前，有一道绕不过去的弯，那就是同步执行、异步执行的概念，以及在什么样的场景下使用同步、异步模型？</p> <ul><li><p>同步执行：所谓同步执行，指的就是在发出一个请求后，<strong>在没有获得调用结果之前，调用者就会等待在当前代码</strong>。直到获取到调用方法的执行结果，才算是结束。总结一句话就是 <strong>由调用者主动等待这个调用的结果，未返回之前不执行别的操作</strong></p></li> <li><p>异步执行：而异步执行恰恰相反，<strong>发出调用请求后立即返回，并向下执行代码</strong>。异步调用方法一般不会有返回结果，调用之后就可以执行别的操作，一般通过回调函数的方式通知调用者结果</p></li></ul> <p>这里给大家举个例子，能够很好的反应同步、异步的概念。比如说你想要给体检医院打电话预约体检，你说出自己想要预约的时间后，对面的小姐姐说：“稍等，我查一下时间是否可以”，这个时候如果你 <strong>不挂电话，等着小姐姐查完告诉你</strong> 之后才挂断电话，那这就是同步。如果她说稍等需要查一下，<strong>你告诉她：“我先挂了，查到结果后再打过来”</strong>，那这就是异步+回调</p> <p>在我们上面写的示例代码上，毋庸置疑是通过同步的形式执行观察者模式，<strong>那是否可以通过异步的方式执行观察者行为</strong>？答案当然是可以。我们可以通过在 <strong>观察者模式行为执行前创建一个线程</strong>，那自然就是异步的。当然，不太建议你这么做，这样可能会牵扯出更多的问题。一起来看下 Guava 和 Spring 是如何封装观察者模式</p> <h2 id="guava-eventbus-解析">Guava EventBus 解析 <a href="#guava-eventbus-解析" class="header-anchor">#</a></h2> <p><code>EventBus</code> 是 <code>Google Guava</code> 提供的消息发布-订阅类库，是设计模式中的观察者模式（生产/消费者模型）的经典实现</p> <p>具体代码已上传 GitHub 代码仓库，<code>EventBus</code> 实现中包含同步、异步两种方式，代码库中由同步方式实现观察者模式</p> <p>因为 <code>EventBus</code> 并不是文章重点，所以这里只会对其原理进行探讨。首先 <strong>EventBus 是一个同步类库</strong>，如果需要使用异步的，那就创建时候指定 <code>AsyncEventBus</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 创建同步 EventBus</span>
<span class="token class-name">EventBus</span> eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建异步 AsyncEventBus</span>
<span class="token class-name">EventBus</span> eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncEventBus</span><span class="token punctuation">(</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong><font color="#FF0000">注意一点</font></strong>，创建 <code>AsyncEventBus</code> 需要指定线程池，其内部并没有默认指定。当然也别像上面代码直接用 <code>Executors</code> 创建，作者是为了图省事，如果从规范而言，还是消停的使用默认线程池构建方法创建 <code>new ThreadPoolExecutor(xxx);</code></p> <p><code>EventBus</code> 同步实现有一个比较有意思的点。观察者操作同步、异步行为时，均使用 <code>Executor</code> 去执行观察者内部代码，那如何保证 <code>Executor</code> 能同步执行呢。Guava 是这么做的：<strong>实现 Executor 接口，重写执行方法，调用 run 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">enum</span> <span class="token class-name">DirectExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    INSTANCE<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大家有兴趣可以去看下 <code>EventBus</code> 源码，不是很难理解，工作使用上还是挺方便的。只不过也有不好的地方，因为 <code>EventBus</code> 属于进程内操作，如果使用异步 <code>AsyncEventBus</code> 执行业务，<strong>存在丢失任务的可能</strong></p> <h2 id="spring-事件模型">Spring 事件模型 <a href="#spring-事件模型" class="header-anchor">#</a></h2> <p>Spring 大拿设计的观察者模式抽象是作者看到的最优雅、最功能的设计</p> <p>如果想要使用 <code>ApplicationEvent</code> 玩转观察者模式，只需要简单几步。总结：操作简单，功能强大</p> <ol><li><p>创建业务相关的 <code>MyEvent</code>，需要继承 <code>ApplicationEvent</code>，重写有参构造函数</p></li> <li><p>定义不同的监听器（观察者）比如 <code>ListenerOne</code> 实现 <code>ApplicationListener&lt;MyEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法</p></li> <li><p>通过 <code>ApplicationContext#publishEvent</code> 方法发布具体事件</p></li></ol> <p>Spring 事件与 Guava EventBus 一样，代码就不粘贴了，都已经存放到 Github 代码仓库。这里重点介绍下 Spring 事件模型的特点，以及使用事项</p> <p>Spring 事件同样支持异步编程，需要在具体 Listener 实现类上添加 <code>@Async</code> 注解。支持 Listener 订阅的顺序，比如说有 A、B、C 三个 Listener。可以通过 <code>@Order</code> 注解实现多个观察者顺序消费</p> <p>作者建议读者朋友一定要跑下 <code>ApplicationEvent</code> 的 Demo，在使用框架的同时也 <strong>要合理的运用框架提供的工具轮子</strong>，因为被框架封装出的功能，一般而言要比自己写的功能更强大、出现问题的几率更少。同时，<strong>切记不要造重复轮子</strong>，除非功能点不满足的情况下，可以借鉴原有轮子的基础上开发自己功能</p> <h2 id="结言">结言 <a href="#结言" class="header-anchor">#</a></h2> <p>文章通过图文并茂的方式帮助大家梳理了下观察者模式的实现方式，更是推出了进阶版的 <code>EventBus</code> 以及 <code>ApplicationEvent</code>，相信大家看完之后可以很愉快的在自己项目中玩耍设计模式了。切记哈，要在合理的场景下使用模式，一般而言观察者模式作用于 <strong>观察者与被观察者之间的解耦合</strong></p> <p>最后解答下最早提到的问题，项目中的观察者模式 <strong>应该使用同步模型还是异步模型呢</strong></p> <p>如果只是使用观察者模式拆分代码使其满足 <strong>开闭原则、高内聚低耦合、职责单一</strong> 等特性，那么自然是使用同步去做，因为这种方式是最为稳妥。而如果 <strong>不关心观察者执行结果或者考虑性能</strong> 等情况，则可以使用异步的方式，通过回调的方式满足业务返回需求</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/18/2022, 9:57:31 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/docs/thread/java8-parallel-stream.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        谨慎使用 Java8 新特性 ParallelStream
      </a></span> <span class="next"><a href="/docs/design/identity-auth.html">
        图解设计模式：身份认证场景的应用
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> <!----> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7eb18571.js" defer></script><script src="/assets/js/2.670b9761.js" defer></script><script src="/assets/js/18.eb50631d.js" defer></script>
  </body>
</html>